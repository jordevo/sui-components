(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{"7HA/":function(n,e){n.exports="import React, {Component, Fragment} from 'react'\nimport PropTypes from 'prop-types'\nimport withIntersectionObserver from './hoc/withIntersectionObserver'\n\nimport {withOpenToggle} from '@s-ui/hoc'\n\nconst BASE_CLASS = 'sui-AtomTooltip'\nconst CLASS_INNER = `${BASE_CLASS}-inner`\nconst CLASS_ARROW = `${BASE_CLASS}-arrow`\nconst PREFIX_PLACEMENT = `${BASE_CLASS}-`\nconst CLASS_TARGET = `${BASE_CLASS}-target`\n\nconst PLACEMENTS = {\n  TOP: 'top',\n  TOP_START: 'top-start',\n  TOP_END: 'top-end',\n  RIGHT: 'right',\n  RIGHT_START: 'right-start',\n  RIGHT_END: 'right-end',\n  BOTTOM: 'bottom',\n  BOTTOM_START: 'bottom-start',\n  BOTTOM_END: 'bottom-end',\n  LEFT: 'left',\n  LEFT_START: 'left-start',\n  LEFT_END: 'left-end'\n}\n\nclass AtomTooltip extends Component {\n  state = {Tooltip: null}\n  preventNonTouchEvents = false\n  hasTouchEnded = false\n  touchTimer = null\n  onClickTarget = null\n  title = null\n  refTooltip = React.createRef()\n  refTarget = React.createRef()\n\n  loadAsyncReacstrap(e) {\n    require.ensure(\n      [],\n      require => {\n        const Tooltip = require('reactstrap/lib/Tooltip').default\n        this.setState({Tooltip})\n        this.handleToggle(e)\n      },\n      'reactstrap-Tooltip'\n    )\n  }\n\n  extendChildren() {\n    const {children} = this.props // eslint-disable-line react/prop-types\n\n    const ref = this.refTarget\n    const className = CLASS_TARGET\n    const onTouchEnd = this.handleToggle\n\n    const childrenOnly = React.Children.only(children)\n\n    return React.Children.map(childrenOnly, child => {\n      this.onClickTarget = child.props.onClick\n      this.title = child.props.title\n      return React.cloneElement(child, {\n        ref,\n        className,\n        onTouchEnd\n      })\n    })\n  }\n\n  componentDidMount() {\n    const target = this.refTarget.current\n    this.props.innerRef(target)\n    ;['touchstart', 'mouseover'].forEach(event =>\n      target.addEventListener(event, e => {\n        if (!this.state.Tooltip) this.loadAsyncReacstrap(e)\n      })\n    )\n    ;['click', 'touchend'].forEach(event =>\n      window.addEventListener(event, this.handleClickOutsideElement)\n    )\n    target.oncontextmenu = this.handleContextMenu\n    target.addEventListener('mouseover', this.disableTitle)\n    target.addEventListener('mouseout', this.restoreTitle)\n  }\n\n  componentWillUnmount() {\n    const target = this.refTarget.current\n    clearTimeout(this.touchTimer)\n    ;['click', 'touchend'].forEach(event =>\n      window.removeEventListener(event, this.handleClickOutsideElement)\n    )\n    target.removeEventListener('mouseover', this.disableTitle)\n    target.removeEventListener('mouseout', this.restoreTitle)\n  }\n\n  disableTitle(e) {\n    this.dataset.title = this.title\n    this.title = ''\n  }\n\n  restoreTitle(e) {\n    this.title = this.dataset.title\n  }\n\n  handleContextMenu = e => {\n    e.preventDefault()\n    e.stopPropagation()\n    return false\n  }\n\n  handleClickOutsideElement = e => {\n    const {isOpen, onToggle} = this.props\n    const target = this.refTarget.current\n    if (isOpen) {\n      const tooltipDom = this.refTooltip.current\n      const isOutside = tooltipDom && !tooltipDom.contains(e.target)\n      const isNotTarget = target && !target.contains(e.target)\n      if (isOutside && isNotTarget) onToggle(e, {isOpen: false})\n    }\n  }\n\n  handleTouchStart = e => {\n    const {longPressTime, onToggle} = this.props\n    this.preventNonTouchEvents = true\n    this.hasTouchEnded = false\n    clearTimeout(this.touchTimer)\n    this.touchTimer = setTimeout(() => {\n      if (!this.hasTouchEnded) onToggle(e)\n      this.preventNonTouchEvents = false\n      this.hasTouchEnded = false\n    }, longPressTime)\n    return false\n  }\n\n  handleTouchEnd = e => {\n    if (!this.preventNonTouchEvents) this.handleStopPropagation(e)\n    this.hasTouchEnded = true\n    clearTimeout(this.touchTimer)\n  }\n\n  handleStopPropagation = e => {\n    e.preventDefault()\n    e.stopPropagation()\n    return false\n  }\n\n  /**\n   * This function is executed when target doesn't have an `onClick` prop (normal targets)\n   * this logic assures that only the proper events triggers the tooltip\n   */\n  handleToggleOnNormalTarget = e => {\n    const {type} = e\n    const {onToggle} = this.props\n    const isValidTrigger = [\n      'click',\n      'focusin',\n      'mouseover',\n      'mouseout'\n    ].includes(type)\n    if (type === 'touchstart') this.hasTouchEnded = false\n    if (type === 'touchend') this.hasTouchEnded = true\n    if (this.hasTouchEnded && ['focusin', 'mouseover'].includes(type)) {\n      this.handleStopPropagation(e)\n    }\n    if (isValidTrigger) onToggle(e)\n  }\n\n  /**\n   * This function is executed when target DOES have an `onClick` prop ('call-to-action' targets)\n   * this logic assures that only the proper events triggers the tooltip\n   */\n  handleToggleOnCallToActionTarget = e => {\n    const {type} = e\n    const {onToggle} = this.props\n    if (type === 'touchstart') this.handleTouchStart(e)\n    if (type === 'touchend') this.handleTouchEnd(e)\n    if (!this.preventNonTouchEvents) onToggle(e)\n  }\n\n  handleToggle = e => {\n    if (this.onClickTarget) this.handleToggleOnCallToActionTarget(e)\n    else this.handleToggleOnNormalTarget(e)\n  }\n\n  render() {\n    const {\n      hideArrow,\n      content: HtmlContent,\n      delay,\n      autohide,\n      placement\n    } = this.props // eslint-disable-line react/prop-types\n\n    const {Tooltip} = this.state\n    const target = this.refTarget.current\n    const restrictedProps = {\n      hideArrow,\n      target,\n      delay,\n      autohide,\n      placement\n    }\n    let {isVisible, isOpen} = this.props // eslint-disable-line react/prop-types\n    if (!isVisible && isOpen) isOpen = false\n\n    return (\n      <Fragment>\n        {this.extendChildren()}\n        {target &&\n          Tooltip && (\n            <Tooltip\n              {...restrictedProps}\n              isOpen={isOpen}\n              toggle={this.handleToggle}\n              className={BASE_CLASS}\n              innerClassName={CLASS_INNER}\n              arrowClassName={CLASS_ARROW}\n              placementPrefix={PREFIX_PLACEMENT}\n              innerRef={this.refTooltip}\n              offset=\"auto,4px\"\n            >\n              {HtmlContent ? <HtmlContent /> : this.title}\n            </Tooltip>\n          )}\n      </Fragment>\n    )\n  }\n}\n\nAtomTooltip.displayName = 'AtomTooltip'\n\nAtomTooltip.defaultProps = {\n  isVisible: true,\n  longPressTime: 1000\n}\n\nAtomTooltip.propTypes = {\n  /** Wether to show arrow or not. */\n  hideArrow: PropTypes.bool,\n\n  /** Optionally override show/hide delays. Default  \u2192 { show: 0, hide: 250 } */\n  delay: PropTypes.oneOfType([\n    PropTypes.shape({\n      show: PropTypes.number,\n      hide: PropTypes.number\n    }),\n    PropTypes.number\n  ]),\n\n  /** optionally hide tooltip when hovering over tooltip content. Default \u2192 true */\n  autohide: PropTypes.bool,\n\n  /** Tooltip and arrow position */\n  placement: PropTypes.oneOf(Object.values(PLACEMENTS)),\n\n  /** True if the target is inside the viewport */\n  isVisible: PropTypes.bool,\n\n  /** True if the tooltip is displayed or not */\n  isOpen: PropTypes.bool,\n\n  /** Handler to set the value of isOpen  */\n  onToggle: PropTypes.func,\n\n  /** HTML (component) to be displayed on the Tooltip */\n  content: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),\n\n  /** Custom ref handler that will be assigned to the \"target\" element */\n  innerRef: PropTypes.oneOfType([\n    PropTypes.func,\n    PropTypes.string,\n    PropTypes.object\n  ]),\n\n  /** Time in miliseconds for longpress duration */\n  longPressTime: PropTypes.number\n}\n\nexport default withIntersectionObserver(withOpenToggle(AtomTooltip))\nexport {AtomTooltip as AtomTooltipBase, PLACEMENTS as atomTooltipPlacements}\n"}}]);