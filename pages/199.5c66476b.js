(window.webpackJsonp=window.webpackJsonp||[]).push([[199],{PZd9:function(n,e){n.exports="import PropTypes from 'prop-types'\nimport React, {Component} from 'react'\nimport {createPortal} from 'react-dom'\nimport cx from 'classnames'\nimport {SUPPORTED_KEYS} from './config'\nimport {suitClass} from './helpers'\nimport {Close} from './Close'\nimport {HeaderRender} from './HeaderRender'\nimport WithAnimation from './HoC/WithAnimation'\n\nconst toggleWindowScroll = disableScroll => {\n  window.document.body.classList.toggle('is-MoleculeModal-open', disableScroll)\n}\n\nclass MoleculeModal extends Component {\n  _contentRef = React.createRef()\n  _wrapperRef = React.createRef()\n\n  state = {\n    isClientReady: false\n  }\n\n  _getContainer() {\n    const {portalContainerId} = this.props\n    let containerDOMEl = document.getElementById(portalContainerId)\n    if (!containerDOMEl) {\n      containerDOMEl = document.createElement('div')\n      containerDOMEl.id = portalContainerId\n      document.body.appendChild(containerDOMEl)\n    }\n    return containerDOMEl\n  }\n\n  componentDidMount() {\n    const {usePortal} = this.props\n    if (usePortal) {\n      this.setState({isClientReady: true})\n    }\n    document.addEventListener('keydown', this._onKeyDown)\n  }\n  componentWillUnmount() {\n    toggleWindowScroll(false)\n    document.removeEventListener('keydown', this._onKeyDown)\n  }\n\n  _onKeyDown = event => {\n    if (this.props.isOpen === false || this.props.closeOnEscKeyDown === false)\n      return\n    if (SUPPORTED_KEYS.includes(event.key)) {\n      this._closeModal()\n      event.preventDefault()\n    }\n  }\n\n  _preventScrollIfNeeded = e => {\n    if (!this.props.enableContentScroll && this.noScroll) e.preventDefault()\n  }\n\n  _avoidOverscroll = () => {\n    const {\n      clientHeight,\n      offsetHeight,\n      scrollTop,\n      scrollHeight\n    } = this._contentRef.current\n    const currentScroll = scrollTop + offsetHeight\n    // check if the content has to scroll in order to prevent the default\n    // behaviour of the touchmove in case we don't need the scroll\n    // that fixes the weird overscroll on ios and android\n    this.noScroll = scrollHeight <= clientHeight\n\n    if (scrollTop === 0) {\n      this._contentRef.current.scrollTop = 1\n    } else if (currentScroll >= scrollHeight) {\n      this._contentRef.current.scrollTop = scrollTop - 1\n    }\n  }\n\n  _closeModal = () => {\n    toggleWindowScroll(false)\n    this.props.onClose()\n  }\n\n  _handleCloseClick = () => {\n    this._closeModal()\n  }\n\n  _handleOutsideClick = event => {\n    if (\n      this.props.closeOnOutsideClick &&\n      event.target === this._wrapperRef.current\n    ) {\n      this._closeModal()\n    }\n  }\n\n  get extendedChildren() {\n    const {children} = this.props\n    return React.Children.toArray(children).map((child, index) => {\n      return React.cloneElement(child, {\n        onClose: this._closeModal\n      })\n    })\n  }\n\n  _renderModal() {\n    const {\n      header,\n      iconClose,\n      isOpen,\n      fitWindow,\n      fitContent,\n      isClosing,\n      onAnimationEnd\n    } = this.props\n\n    const wrapperClassName = cx(suitClass(), {\n      'is-MoleculeModal-open': isOpen,\n      [suitClass({element: 'out'})]: isClosing\n    })\n\n    const dialogClassName = cx(suitClass({element: 'dialog'}), {\n      [suitClass({element: 'dialog--full'})]: fitWindow,\n      [suitClass({element: 'dialog--out'})]: isClosing,\n      [suitClass({element: 'dialog--fit'})]: fitContent\n    })\n\n    return (\n      <div\n        className={wrapperClassName}\n        ref={this._wrapperRef}\n        onAnimationEnd={onAnimationEnd}\n        onClick={this._handleOutsideClick}\n      >\n        <div className={dialogClassName}>\n          {(iconClose || header) && (\n            <HeaderRender\n              close={\n                iconClose && (\n                  <Close icon={iconClose} onClick={this._handleCloseClick} />\n                )\n              }\n              header={header}\n            />\n          )}\n          <div\n            className={suitClass({element: 'content'})}\n            onTouchStart={this._avoidOverscroll}\n            onTouchMove={this._preventScrollIfNeeded}\n            ref={this._contentRef}\n          >\n            {this.extendedChildren}\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  render() {\n    const {isOpen, usePortal} = this.props\n    const {isClientReady} = this.state\n\n    const modalElement = this._renderModal()\n\n    if (usePortal) {\n      return isClientReady\n        ? createPortal(modalElement, this._getContainer())\n        : null\n    }\n\n    // temporary fix to avoid executing this on SSR\n    // we should move to functions this and create as a function\n    if (isClientReady) {\n      toggleWindowScroll(isOpen)\n    }\n\n    return modalElement\n  }\n}\n\nMoleculeModal.propTypes = {\n  /**\n   * true if you want close the modal by clicking outside the modal itself, otherwise, false\n   */\n  closeOnOutsideClick: PropTypes.bool,\n  /**\n   * true if you want to let the ESC key to close the modal, otherwise, false\n   */\n  closeOnEscKeyDown: PropTypes.bool,\n  /**\n   * The content of the modal itself\n   */\n  children: PropTypes.node,\n  /**\n   * true to prevent scroll\n   */\n  enableContentScroll: PropTypes.bool,\n  /**\n   * true if you want a fullscreen modal, otherwise, false\n   */\n  fitWindow: PropTypes.bool,\n  /**\n   * true if you want a modal that fit contents in mobile devices, otherwise, false\n   */\n  fitContent: PropTypes.bool,\n  /**\n   * content of the modal's header\n   */\n  header: PropTypes.element,\n  /**\n   * customitzable close icon\n   */\n  iconClose: PropTypes.element,\n  /**\n   * prop to mark if the modal is currently open or not\n   */\n  isOpen: PropTypes.bool,\n  /**\n   * onClose function handler\n   */\n  onClose: PropTypes.func,\n  /**\n   * A boolean to identify if the modal is being closed or not used by the HoC WithAnimation\n   */\n  isClosing: PropTypes.bool,\n  /**\n   * The callback function to be called when the animation ends, defined by the HoC WithAnimation\n   */\n  onAnimationEnd: PropTypes.func,\n  /**\n   * Container id element to be used to render the portal. If not available, it will be created for you.\n   */\n  portalContainerId: PropTypes.string,\n  /**\n   * Determines if modal will be rendered using a React Portal.\n   */\n  usePortal: PropTypes.bool\n}\n\nMoleculeModal.defaultProps = {\n  closeOnOutsideClick: false,\n  closeOnEscKeyDown: false,\n  enableContentScroll: false,\n  fitWindow: false,\n  fitContent: false,\n  isOpen: false,\n  portalContainerId: 'modal-react-portal',\n  usePortal: true,\n  onClose: () => {}\n}\n\nMoleculeModal.displayName = 'MoleculeModal'\n\nexport default WithAnimation(MoleculeModal)\n"}}]);